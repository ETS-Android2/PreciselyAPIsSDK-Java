/**
 * Precisely APIs
 * Enhance & enrich your data, applications, business processes, and workflows with rich location, information, and identify APIs.
 *
 * OpenAPI spec version: 11.6.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package com.precisely.apis;

import com.precisely.ApiCallback;
import com.precisely.ApiClient;
import com.precisely.ApiException;
import com.precisely.ApiResponse;
import com.precisely.Configuration;
import com.precisely.Pair;
import com.precisely.ProgressRequestBody;
import com.precisely.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;

import com.precisely.apis.model.CrimeRiskResponse;
import com.precisely.apis.model.CrimeRiskByAddressRequest;
import com.precisely.apis.model.CrimeRiskResponseList;
import com.precisely.apis.model.CrimeRiskLocationResponse;
import com.precisely.apis.model.CrimeRiskByLocationRequest;
import com.precisely.apis.model.CrimeRiskLocationResponseList;
import com.precisely.apis.model.WaterBodyResponse;
import com.precisely.apis.model.DistanceToFloodHazardResponse;
import com.precisely.apis.model.DistanceToFloodHazardAddressRequest;
import com.precisely.apis.model.WaterBodyLocationResponse;
import com.precisely.apis.model.DistanceToFloodHazardLocationResponse;
import com.precisely.apis.model.DistanceToFloodHazardLocationRequest;
import com.precisely.apis.model.EarthquakeHistory;
import com.precisely.apis.model.EarthquakeRiskResponse;
import com.precisely.apis.model.EarthquakeRiskByAddressRequest;
import com.precisely.apis.model.EarthquakeRiskResponseList;
import com.precisely.apis.model.EarthquakeRiskLocationResponse;
import com.precisely.apis.model.EarthquakeRiskLocationResponseList;
import com.precisely.apis.model.EarthquakeRiskByLocationRequest;
import com.precisely.apis.model.FireHistory;
import com.precisely.apis.model.FireRiskResponse;
import com.precisely.apis.model.FireRiskByAddressRequest;
import com.precisely.apis.model.FireRiskResponseList;
import com.precisely.apis.model.FireRiskLocationResponse;
import com.precisely.apis.model.FireRiskLocationResponseList;
import com.precisely.apis.model.FireRiskByLocationRequest;
import com.precisely.apis.model.FireStations;
import com.precisely.apis.model.FireStationsLocation;
import com.precisely.apis.model.FloodRiskResponse;
import com.precisely.apis.model.FloodRiskByAddressRequest;
import com.precisely.apis.model.FloodRiskResponseList;
import com.precisely.apis.model.FloodRiskLocationResponse;
import com.precisely.apis.model.FloodRiskByLocationRequest;
import com.precisely.apis.model.FloodRiskLocationResponseList;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class RisksServiceApi {
    private ApiClient apiClient;

    public RisksServiceApi() {
        this(Configuration.getDefaultApiClient());
    }

    public RisksServiceApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /* Build call for getCrimeRiskByAddress */
    private com.squareup.okhttp.Call getCrimeRiskByAddressCall(String address, String type, String includeGeometry, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'address' is set
        if (address == null) {
            throw new ApiException("Missing the required parameter 'address' when calling getCrimeRiskByAddress(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/risks/v1/crime/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (address != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "address", address));
        if (type != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "type", type));
        if (includeGeometry != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "includeGeometry", includeGeometry));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Get Crime Risk By Address
     * Accepts addresses as input and Returns local crime indexes.
     * @param address Free-form address text. (required)
     * @param type Type of crime like violent crime, property crime, etc., multiple crime type indexes could be requested as comma separated values with &#39;all&#39; as default.) (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return CrimeRiskResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public CrimeRiskResponse getCrimeRiskByAddress(String address, String type, String includeGeometry) throws ApiException {
        ApiResponse<CrimeRiskResponse> resp = getCrimeRiskByAddressWithHttpInfo(address, type, includeGeometry);
        return resp.getData();
    }

    /**
     * Get Crime Risk By Address
     * Accepts addresses as input and Returns local crime indexes.
     * @param address Free-form address text. (required)
     * @param type Type of crime like violent crime, property crime, etc., multiple crime type indexes could be requested as comma separated values with &#39;all&#39; as default.) (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return ApiResponse&lt;CrimeRiskResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<CrimeRiskResponse> getCrimeRiskByAddressWithHttpInfo(String address, String type, String includeGeometry) throws ApiException {
        com.squareup.okhttp.Call call = getCrimeRiskByAddressCall(address, type, includeGeometry, null, null);
        Type localVarReturnType = new TypeToken<CrimeRiskResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get Crime Risk By Address (asynchronously)
     * Accepts addresses as input and Returns local crime indexes.
     * @param address Free-form address text. (required)
     * @param type Type of crime like violent crime, property crime, etc., multiple crime type indexes could be requested as comma separated values with &#39;all&#39; as default.) (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getCrimeRiskByAddressAsync(String address, String type, String includeGeometry, final ApiCallback<CrimeRiskResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCrimeRiskByAddressCall(address, type, includeGeometry, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<CrimeRiskResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getCrimeRiskByAddressBatch */
    private com.squareup.okhttp.Call getCrimeRiskByAddressBatchCall(CrimeRiskByAddressRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        

        // create path and map variables
        String localVarPath = "/risks/v1/crime/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Post Crime Risk By Address
     * This is a Batch offering for &#39;Crime Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve local crime indexes.
     * @param body  (optional)
     * @return CrimeRiskResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public CrimeRiskResponseList getCrimeRiskByAddressBatch(CrimeRiskByAddressRequest body) throws ApiException {
        ApiResponse<CrimeRiskResponseList> resp = getCrimeRiskByAddressBatchWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Post Crime Risk By Address
     * This is a Batch offering for &#39;Crime Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve local crime indexes.
     * @param body  (optional)
     * @return ApiResponse&lt;CrimeRiskResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<CrimeRiskResponseList> getCrimeRiskByAddressBatchWithHttpInfo(CrimeRiskByAddressRequest body) throws ApiException {
        com.squareup.okhttp.Call call = getCrimeRiskByAddressBatchCall(body, null, null);
        Type localVarReturnType = new TypeToken<CrimeRiskResponseList>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Post Crime Risk By Address (asynchronously)
     * This is a Batch offering for &#39;Crime Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve local crime indexes.
     * @param body  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getCrimeRiskByAddressBatchAsync(CrimeRiskByAddressRequest body, final ApiCallback<CrimeRiskResponseList> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCrimeRiskByAddressBatchCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<CrimeRiskResponseList>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getCrimeRiskByLocation */
    private com.squareup.okhttp.Call getCrimeRiskByLocationCall(String longitude, String latitude, String type, String includeGeometry, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'longitude' is set
        if (longitude == null) {
            throw new ApiException("Missing the required parameter 'longitude' when calling getCrimeRiskByLocation(Async)");
        }
        
        // verify the required parameter 'latitude' is set
        if (latitude == null) {
            throw new ApiException("Missing the required parameter 'latitude' when calling getCrimeRiskByLocation(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/risks/v1/crime/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (longitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "longitude", longitude));
        if (latitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "latitude", latitude));
        if (type != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "type", type));
        if (includeGeometry != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "includeGeometry", includeGeometry));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Get Crime Risk By Location
     * Returns the crime data or crime indexes for a given location.
     * @param longitude The longitude of the location (required)
     * @param latitude The latitude of the location (required)
     * @param type Refers to crime type. Valid values are following 11 crime types with &#39;all&#39; as default (more than one can also be given as comma separated types) (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return CrimeRiskLocationResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public CrimeRiskLocationResponse getCrimeRiskByLocation(String longitude, String latitude, String type, String includeGeometry) throws ApiException {
        ApiResponse<CrimeRiskLocationResponse> resp = getCrimeRiskByLocationWithHttpInfo(longitude, latitude, type, includeGeometry);
        return resp.getData();
    }

    /**
     * Get Crime Risk By Location
     * Returns the crime data or crime indexes for a given location.
     * @param longitude The longitude of the location (required)
     * @param latitude The latitude of the location (required)
     * @param type Refers to crime type. Valid values are following 11 crime types with &#39;all&#39; as default (more than one can also be given as comma separated types) (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return ApiResponse&lt;CrimeRiskLocationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<CrimeRiskLocationResponse> getCrimeRiskByLocationWithHttpInfo(String longitude, String latitude, String type, String includeGeometry) throws ApiException {
        com.squareup.okhttp.Call call = getCrimeRiskByLocationCall(longitude, latitude, type, includeGeometry, null, null);
        Type localVarReturnType = new TypeToken<CrimeRiskLocationResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get Crime Risk By Location (asynchronously)
     * Returns the crime data or crime indexes for a given location.
     * @param longitude The longitude of the location (required)
     * @param latitude The latitude of the location (required)
     * @param type Refers to crime type. Valid values are following 11 crime types with &#39;all&#39; as default (more than one can also be given as comma separated types) (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getCrimeRiskByLocationAsync(String longitude, String latitude, String type, String includeGeometry, final ApiCallback<CrimeRiskLocationResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCrimeRiskByLocationCall(longitude, latitude, type, includeGeometry, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<CrimeRiskLocationResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getCrimeRiskByLocationBatch */
    private com.squareup.okhttp.Call getCrimeRiskByLocationBatchCall(CrimeRiskByLocationRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        

        // create path and map variables
        String localVarPath = "/risks/v1/crime/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Post Crime Risk By Location
     * This is a Batch offering for &#39;Crime Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve local crime indexes.
     * @param body  (optional)
     * @return CrimeRiskLocationResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public CrimeRiskLocationResponseList getCrimeRiskByLocationBatch(CrimeRiskByLocationRequest body) throws ApiException {
        ApiResponse<CrimeRiskLocationResponseList> resp = getCrimeRiskByLocationBatchWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Post Crime Risk By Location
     * This is a Batch offering for &#39;Crime Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve local crime indexes.
     * @param body  (optional)
     * @return ApiResponse&lt;CrimeRiskLocationResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<CrimeRiskLocationResponseList> getCrimeRiskByLocationBatchWithHttpInfo(CrimeRiskByLocationRequest body) throws ApiException {
        com.squareup.okhttp.Call call = getCrimeRiskByLocationBatchCall(body, null, null);
        Type localVarReturnType = new TypeToken<CrimeRiskLocationResponseList>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Post Crime Risk By Location (asynchronously)
     * This is a Batch offering for &#39;Crime Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve local crime indexes.
     * @param body  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getCrimeRiskByLocationBatchAsync(CrimeRiskByLocationRequest body, final ApiCallback<CrimeRiskLocationResponseList> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCrimeRiskByLocationBatchCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<CrimeRiskLocationResponseList>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getDistanceToFloodHazardByAddress */
    private com.squareup.okhttp.Call getDistanceToFloodHazardByAddressCall(String address, String maxCandidates, String waterBodyType, String searchDistance, String searchDistanceUnit, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'address' is set
        if (address == null) {
            throw new ApiException("Missing the required parameter 'address' when calling getDistanceToFloodHazardByAddress(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/risks/v1/shoreline/distancetofloodhazard/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (address != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "address", address));
        if (maxCandidates != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "maxCandidates", maxCandidates));
        if (waterBodyType != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "waterBodyType", waterBodyType));
        if (searchDistance != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "searchDistance", searchDistance));
        if (searchDistanceUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "searchDistanceUnit", searchDistanceUnit));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Get Distance To Flood Hazard By Address
     * Accepts addresses as input and Returns the distance from nearest water bodies along with body name and location.
     * @param address The address of the location (required)
     * @param maxCandidates This specifies the value of maxCandidates (optional)
     * @param waterBodyType all (default value), oceanandsea,lake,others,unknown,intermittent (optional)
     * @param searchDistance This specifies the search distance (optional)
     * @param searchDistanceUnit miles (default value),feet, kilometers, meters (optional)
     * @return WaterBodyResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public WaterBodyResponse getDistanceToFloodHazardByAddress(String address, String maxCandidates, String waterBodyType, String searchDistance, String searchDistanceUnit) throws ApiException {
        ApiResponse<WaterBodyResponse> resp = getDistanceToFloodHazardByAddressWithHttpInfo(address, maxCandidates, waterBodyType, searchDistance, searchDistanceUnit);
        return resp.getData();
    }

    /**
     * Get Distance To Flood Hazard By Address
     * Accepts addresses as input and Returns the distance from nearest water bodies along with body name and location.
     * @param address The address of the location (required)
     * @param maxCandidates This specifies the value of maxCandidates (optional)
     * @param waterBodyType all (default value), oceanandsea,lake,others,unknown,intermittent (optional)
     * @param searchDistance This specifies the search distance (optional)
     * @param searchDistanceUnit miles (default value),feet, kilometers, meters (optional)
     * @return ApiResponse&lt;WaterBodyResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<WaterBodyResponse> getDistanceToFloodHazardByAddressWithHttpInfo(String address, String maxCandidates, String waterBodyType, String searchDistance, String searchDistanceUnit) throws ApiException {
        com.squareup.okhttp.Call call = getDistanceToFloodHazardByAddressCall(address, maxCandidates, waterBodyType, searchDistance, searchDistanceUnit, null, null);
        Type localVarReturnType = new TypeToken<WaterBodyResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get Distance To Flood Hazard By Address (asynchronously)
     * Accepts addresses as input and Returns the distance from nearest water bodies along with body name and location.
     * @param address The address of the location (required)
     * @param maxCandidates This specifies the value of maxCandidates (optional)
     * @param waterBodyType all (default value), oceanandsea,lake,others,unknown,intermittent (optional)
     * @param searchDistance This specifies the search distance (optional)
     * @param searchDistanceUnit miles (default value),feet, kilometers, meters (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getDistanceToFloodHazardByAddressAsync(String address, String maxCandidates, String waterBodyType, String searchDistance, String searchDistanceUnit, final ApiCallback<WaterBodyResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getDistanceToFloodHazardByAddressCall(address, maxCandidates, waterBodyType, searchDistance, searchDistanceUnit, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<WaterBodyResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getDistanceToFloodHazardByAddressBatch */
    private com.squareup.okhttp.Call getDistanceToFloodHazardByAddressBatchCall(DistanceToFloodHazardAddressRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        

        // create path and map variables
        String localVarPath = "/risks/v1/shoreline/distancetofloodhazard/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Post Distance To Flood Hazard By Address
     * This is a Batch offering for &#39;Distance To Flood Hazard By Address&#39; service. It accepts a single address or a list of addresses and retrieve the distance from nearest water bodies along with body name and location.
     * @param body  (optional)
     * @return DistanceToFloodHazardResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public DistanceToFloodHazardResponse getDistanceToFloodHazardByAddressBatch(DistanceToFloodHazardAddressRequest body) throws ApiException {
        ApiResponse<DistanceToFloodHazardResponse> resp = getDistanceToFloodHazardByAddressBatchWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Post Distance To Flood Hazard By Address
     * This is a Batch offering for &#39;Distance To Flood Hazard By Address&#39; service. It accepts a single address or a list of addresses and retrieve the distance from nearest water bodies along with body name and location.
     * @param body  (optional)
     * @return ApiResponse&lt;DistanceToFloodHazardResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<DistanceToFloodHazardResponse> getDistanceToFloodHazardByAddressBatchWithHttpInfo(DistanceToFloodHazardAddressRequest body) throws ApiException {
        com.squareup.okhttp.Call call = getDistanceToFloodHazardByAddressBatchCall(body, null, null);
        Type localVarReturnType = new TypeToken<DistanceToFloodHazardResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Post Distance To Flood Hazard By Address (asynchronously)
     * This is a Batch offering for &#39;Distance To Flood Hazard By Address&#39; service. It accepts a single address or a list of addresses and retrieve the distance from nearest water bodies along with body name and location.
     * @param body  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getDistanceToFloodHazardByAddressBatchAsync(DistanceToFloodHazardAddressRequest body, final ApiCallback<DistanceToFloodHazardResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getDistanceToFloodHazardByAddressBatchCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<DistanceToFloodHazardResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getDistanceToFloodHazardByLocation */
    private com.squareup.okhttp.Call getDistanceToFloodHazardByLocationCall(String longitude, String latitude, String maxCandidates, String waterBodyType, String searchDistance, String searchDistanceUnit, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'longitude' is set
        if (longitude == null) {
            throw new ApiException("Missing the required parameter 'longitude' when calling getDistanceToFloodHazardByLocation(Async)");
        }
        
        // verify the required parameter 'latitude' is set
        if (latitude == null) {
            throw new ApiException("Missing the required parameter 'latitude' when calling getDistanceToFloodHazardByLocation(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/risks/v1/shoreline/distancetofloodhazard/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (longitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "longitude", longitude));
        if (latitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "latitude", latitude));
        if (maxCandidates != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "maxCandidates", maxCandidates));
        if (waterBodyType != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "waterBodyType", waterBodyType));
        if (searchDistance != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "searchDistance", searchDistance));
        if (searchDistanceUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "searchDistanceUnit", searchDistanceUnit));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Get Distance To Flood Hazard By Location
     * Accepts latitude &amp; longitude as input and Returns the distance from nearest water bodies along with body name and location.
     * @param longitude The longitude of the location (required)
     * @param latitude The latitude of the location (required)
     * @param maxCandidates This specifies the value of maxCandidates (optional)
     * @param waterBodyType all (default value), oceanandsea,lake,others,unknown,intermittent (optional)
     * @param searchDistance This specifies the search distance (optional)
     * @param searchDistanceUnit miles (default value),feet, kilometers, meters (optional)
     * @return WaterBodyLocationResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public WaterBodyLocationResponse getDistanceToFloodHazardByLocation(String longitude, String latitude, String maxCandidates, String waterBodyType, String searchDistance, String searchDistanceUnit) throws ApiException {
        ApiResponse<WaterBodyLocationResponse> resp = getDistanceToFloodHazardByLocationWithHttpInfo(longitude, latitude, maxCandidates, waterBodyType, searchDistance, searchDistanceUnit);
        return resp.getData();
    }

    /**
     * Get Distance To Flood Hazard By Location
     * Accepts latitude &amp; longitude as input and Returns the distance from nearest water bodies along with body name and location.
     * @param longitude The longitude of the location (required)
     * @param latitude The latitude of the location (required)
     * @param maxCandidates This specifies the value of maxCandidates (optional)
     * @param waterBodyType all (default value), oceanandsea,lake,others,unknown,intermittent (optional)
     * @param searchDistance This specifies the search distance (optional)
     * @param searchDistanceUnit miles (default value),feet, kilometers, meters (optional)
     * @return ApiResponse&lt;WaterBodyLocationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<WaterBodyLocationResponse> getDistanceToFloodHazardByLocationWithHttpInfo(String longitude, String latitude, String maxCandidates, String waterBodyType, String searchDistance, String searchDistanceUnit) throws ApiException {
        com.squareup.okhttp.Call call = getDistanceToFloodHazardByLocationCall(longitude, latitude, maxCandidates, waterBodyType, searchDistance, searchDistanceUnit, null, null);
        Type localVarReturnType = new TypeToken<WaterBodyLocationResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get Distance To Flood Hazard By Location (asynchronously)
     * Accepts latitude &amp; longitude as input and Returns the distance from nearest water bodies along with body name and location.
     * @param longitude The longitude of the location (required)
     * @param latitude The latitude of the location (required)
     * @param maxCandidates This specifies the value of maxCandidates (optional)
     * @param waterBodyType all (default value), oceanandsea,lake,others,unknown,intermittent (optional)
     * @param searchDistance This specifies the search distance (optional)
     * @param searchDistanceUnit miles (default value),feet, kilometers, meters (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getDistanceToFloodHazardByLocationAsync(String longitude, String latitude, String maxCandidates, String waterBodyType, String searchDistance, String searchDistanceUnit, final ApiCallback<WaterBodyLocationResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getDistanceToFloodHazardByLocationCall(longitude, latitude, maxCandidates, waterBodyType, searchDistance, searchDistanceUnit, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<WaterBodyLocationResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getDistanceToFloodHazardByLocationBatch */
    private com.squareup.okhttp.Call getDistanceToFloodHazardByLocationBatchCall(DistanceToFloodHazardLocationRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        

        // create path and map variables
        String localVarPath = "/risks/v1/shoreline/distancetofloodhazard/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Post Distance To Flood Hazard By Location
     * This is a Batch offering for &#39;Distance To Flood Hazard By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve the distance from nearest water bodies along with body name and location.
     * @param body  (optional)
     * @return DistanceToFloodHazardLocationResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public DistanceToFloodHazardLocationResponse getDistanceToFloodHazardByLocationBatch(DistanceToFloodHazardLocationRequest body) throws ApiException {
        ApiResponse<DistanceToFloodHazardLocationResponse> resp = getDistanceToFloodHazardByLocationBatchWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Post Distance To Flood Hazard By Location
     * This is a Batch offering for &#39;Distance To Flood Hazard By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve the distance from nearest water bodies along with body name and location.
     * @param body  (optional)
     * @return ApiResponse&lt;DistanceToFloodHazardLocationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<DistanceToFloodHazardLocationResponse> getDistanceToFloodHazardByLocationBatchWithHttpInfo(DistanceToFloodHazardLocationRequest body) throws ApiException {
        com.squareup.okhttp.Call call = getDistanceToFloodHazardByLocationBatchCall(body, null, null);
        Type localVarReturnType = new TypeToken<DistanceToFloodHazardLocationResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Post Distance To Flood Hazard By Location (asynchronously)
     * This is a Batch offering for &#39;Distance To Flood Hazard By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve the distance from nearest water bodies along with body name and location.
     * @param body  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getDistanceToFloodHazardByLocationBatchAsync(DistanceToFloodHazardLocationRequest body, final ApiCallback<DistanceToFloodHazardLocationResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getDistanceToFloodHazardByLocationBatchCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<DistanceToFloodHazardLocationResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getEarthquakeHistory */
    private com.squareup.okhttp.Call getEarthquakeHistoryCall(String postCode, String startDate, String endDate, String minMagnitude, String maxMagnitude, String maxCandidates, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'postCode' is set
        if (postCode == null) {
            throw new ApiException("Missing the required parameter 'postCode' when calling getEarthquakeHistory(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/risks/v1/earthquakehistory".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (postCode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "postCode", postCode));
        if (startDate != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "startDate", startDate));
        if (endDate != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "endDate", endDate));
        if (minMagnitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "minMagnitude", minMagnitude));
        if (maxMagnitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "maxMagnitude", maxMagnitude));
        if (maxCandidates != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "maxCandidates", maxCandidates));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Earthquake History
     * Accepts postcode as input and Returns historical earthquake details for a particular postcode.
     * @param postCode 5 digit Postal code to search (required)
     * @param startDate Start time in milliseconds(UTC) (optional)
     * @param endDate End time in milliseconds(UTC) (optional)
     * @param minMagnitude Minimum richter scale magnitude (optional)
     * @param maxMagnitude Maximum Richter scale magnitude (optional)
     * @param maxCandidates Maximum response events (optional, default to 1)
     * @return EarthquakeHistory
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public EarthquakeHistory getEarthquakeHistory(String postCode, String startDate, String endDate, String minMagnitude, String maxMagnitude, String maxCandidates) throws ApiException {
        ApiResponse<EarthquakeHistory> resp = getEarthquakeHistoryWithHttpInfo(postCode, startDate, endDate, minMagnitude, maxMagnitude, maxCandidates);
        return resp.getData();
    }

    /**
     * Earthquake History
     * Accepts postcode as input and Returns historical earthquake details for a particular postcode.
     * @param postCode 5 digit Postal code to search (required)
     * @param startDate Start time in milliseconds(UTC) (optional)
     * @param endDate End time in milliseconds(UTC) (optional)
     * @param minMagnitude Minimum richter scale magnitude (optional)
     * @param maxMagnitude Maximum Richter scale magnitude (optional)
     * @param maxCandidates Maximum response events (optional, default to 1)
     * @return ApiResponse&lt;EarthquakeHistory&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<EarthquakeHistory> getEarthquakeHistoryWithHttpInfo(String postCode, String startDate, String endDate, String minMagnitude, String maxMagnitude, String maxCandidates) throws ApiException {
        com.squareup.okhttp.Call call = getEarthquakeHistoryCall(postCode, startDate, endDate, minMagnitude, maxMagnitude, maxCandidates, null, null);
        Type localVarReturnType = new TypeToken<EarthquakeHistory>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Earthquake History (asynchronously)
     * Accepts postcode as input and Returns historical earthquake details for a particular postcode.
     * @param postCode 5 digit Postal code to search (required)
     * @param startDate Start time in milliseconds(UTC) (optional)
     * @param endDate End time in milliseconds(UTC) (optional)
     * @param minMagnitude Minimum richter scale magnitude (optional)
     * @param maxMagnitude Maximum Richter scale magnitude (optional)
     * @param maxCandidates Maximum response events (optional, default to 1)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getEarthquakeHistoryAsync(String postCode, String startDate, String endDate, String minMagnitude, String maxMagnitude, String maxCandidates, final ApiCallback<EarthquakeHistory> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getEarthquakeHistoryCall(postCode, startDate, endDate, minMagnitude, maxMagnitude, maxCandidates, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<EarthquakeHistory>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getEarthquakeRiskByAddress */
    private com.squareup.okhttp.Call getEarthquakeRiskByAddressCall(String address, String richterValue, String includeGeometry, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'address' is set
        if (address == null) {
            throw new ApiException("Missing the required parameter 'address' when calling getEarthquakeRiskByAddress(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/risks/v1/earthquake/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (address != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "address", address));
        if (richterValue != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "richterValue", richterValue));
        if (includeGeometry != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "includeGeometry", includeGeometry));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Get Earthquake Risk By Address
     * Accepts addresses as input and Returns counts of earthquakes for various richter measurements and values.
     * @param address Free-form address text (required)
     * @param richterValue Richter values like R5 (count of richter scale 5 events), R7 (count of richter scale 7 events), R6_GE (count of events &gt;&#x3D; richter scale 6), etc., multiple richter scales could be requested as comma separated values with &#39;all&#39; as default. Valid values: All (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return EarthquakeRiskResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public EarthquakeRiskResponse getEarthquakeRiskByAddress(String address, String richterValue, String includeGeometry) throws ApiException {
        ApiResponse<EarthquakeRiskResponse> resp = getEarthquakeRiskByAddressWithHttpInfo(address, richterValue, includeGeometry);
        return resp.getData();
    }

    /**
     * Get Earthquake Risk By Address
     * Accepts addresses as input and Returns counts of earthquakes for various richter measurements and values.
     * @param address Free-form address text (required)
     * @param richterValue Richter values like R5 (count of richter scale 5 events), R7 (count of richter scale 7 events), R6_GE (count of events &gt;&#x3D; richter scale 6), etc., multiple richter scales could be requested as comma separated values with &#39;all&#39; as default. Valid values: All (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return ApiResponse&lt;EarthquakeRiskResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<EarthquakeRiskResponse> getEarthquakeRiskByAddressWithHttpInfo(String address, String richterValue, String includeGeometry) throws ApiException {
        com.squareup.okhttp.Call call = getEarthquakeRiskByAddressCall(address, richterValue, includeGeometry, null, null);
        Type localVarReturnType = new TypeToken<EarthquakeRiskResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get Earthquake Risk By Address (asynchronously)
     * Accepts addresses as input and Returns counts of earthquakes for various richter measurements and values.
     * @param address Free-form address text (required)
     * @param richterValue Richter values like R5 (count of richter scale 5 events), R7 (count of richter scale 7 events), R6_GE (count of events &gt;&#x3D; richter scale 6), etc., multiple richter scales could be requested as comma separated values with &#39;all&#39; as default. Valid values: All (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getEarthquakeRiskByAddressAsync(String address, String richterValue, String includeGeometry, final ApiCallback<EarthquakeRiskResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getEarthquakeRiskByAddressCall(address, richterValue, includeGeometry, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<EarthquakeRiskResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getEarthquakeRiskByAddressBatch */
    private com.squareup.okhttp.Call getEarthquakeRiskByAddressBatchCall(EarthquakeRiskByAddressRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        

        // create path and map variables
        String localVarPath = "/risks/v1/earthquake/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Post Earthquake Risk By Address
     * This is a Batch offering for &#39;Earthquake Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve counts of earthquakes for various richter measurements and values.
     * @param body  (optional)
     * @return EarthquakeRiskResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public EarthquakeRiskResponseList getEarthquakeRiskByAddressBatch(EarthquakeRiskByAddressRequest body) throws ApiException {
        ApiResponse<EarthquakeRiskResponseList> resp = getEarthquakeRiskByAddressBatchWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Post Earthquake Risk By Address
     * This is a Batch offering for &#39;Earthquake Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve counts of earthquakes for various richter measurements and values.
     * @param body  (optional)
     * @return ApiResponse&lt;EarthquakeRiskResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<EarthquakeRiskResponseList> getEarthquakeRiskByAddressBatchWithHttpInfo(EarthquakeRiskByAddressRequest body) throws ApiException {
        com.squareup.okhttp.Call call = getEarthquakeRiskByAddressBatchCall(body, null, null);
        Type localVarReturnType = new TypeToken<EarthquakeRiskResponseList>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Post Earthquake Risk By Address (asynchronously)
     * This is a Batch offering for &#39;Earthquake Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve counts of earthquakes for various richter measurements and values.
     * @param body  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getEarthquakeRiskByAddressBatchAsync(EarthquakeRiskByAddressRequest body, final ApiCallback<EarthquakeRiskResponseList> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getEarthquakeRiskByAddressBatchCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<EarthquakeRiskResponseList>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getEarthquakeRiskByLocation */
    private com.squareup.okhttp.Call getEarthquakeRiskByLocationCall(String longitude, String latitude, String richterValue, String includeGeometry, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'longitude' is set
        if (longitude == null) {
            throw new ApiException("Missing the required parameter 'longitude' when calling getEarthquakeRiskByLocation(Async)");
        }
        
        // verify the required parameter 'latitude' is set
        if (latitude == null) {
            throw new ApiException("Missing the required parameter 'latitude' when calling getEarthquakeRiskByLocation(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/risks/v1/earthquake/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (longitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "longitude", longitude));
        if (latitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "latitude", latitude));
        if (richterValue != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "richterValue", richterValue));
        if (includeGeometry != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "includeGeometry", includeGeometry));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Get Earthquake Risk By Location
     * Accepts latitude &amp; longitude as input and Returns counts of earthquakes for various richter measurements and values.
     * @param longitude The longitude of the location (required)
     * @param latitude The latitude of the location (required)
     * @param richterValue Richter values like R5 (count of richter scale 5 events), R7 (count of richter scale 7 events), R6_GE (count of events &gt;&#x3D; richter scale 6), etc., multiple richter scales could be requested as comma separated values with &#39;all&#39; as default. Valid values: All (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return EarthquakeRiskLocationResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public EarthquakeRiskLocationResponse getEarthquakeRiskByLocation(String longitude, String latitude, String richterValue, String includeGeometry) throws ApiException {
        ApiResponse<EarthquakeRiskLocationResponse> resp = getEarthquakeRiskByLocationWithHttpInfo(longitude, latitude, richterValue, includeGeometry);
        return resp.getData();
    }

    /**
     * Get Earthquake Risk By Location
     * Accepts latitude &amp; longitude as input and Returns counts of earthquakes for various richter measurements and values.
     * @param longitude The longitude of the location (required)
     * @param latitude The latitude of the location (required)
     * @param richterValue Richter values like R5 (count of richter scale 5 events), R7 (count of richter scale 7 events), R6_GE (count of events &gt;&#x3D; richter scale 6), etc., multiple richter scales could be requested as comma separated values with &#39;all&#39; as default. Valid values: All (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return ApiResponse&lt;EarthquakeRiskLocationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<EarthquakeRiskLocationResponse> getEarthquakeRiskByLocationWithHttpInfo(String longitude, String latitude, String richterValue, String includeGeometry) throws ApiException {
        com.squareup.okhttp.Call call = getEarthquakeRiskByLocationCall(longitude, latitude, richterValue, includeGeometry, null, null);
        Type localVarReturnType = new TypeToken<EarthquakeRiskLocationResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get Earthquake Risk By Location (asynchronously)
     * Accepts latitude &amp; longitude as input and Returns counts of earthquakes for various richter measurements and values.
     * @param longitude The longitude of the location (required)
     * @param latitude The latitude of the location (required)
     * @param richterValue Richter values like R5 (count of richter scale 5 events), R7 (count of richter scale 7 events), R6_GE (count of events &gt;&#x3D; richter scale 6), etc., multiple richter scales could be requested as comma separated values with &#39;all&#39; as default. Valid values: All (default value), R0, R1, R2, R3, R4, R5, R6, R7, R0_GE, R1_GE, R2_GE, R3_GE, R4_GE, R5_GE, R6_GE, R7_GE (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getEarthquakeRiskByLocationAsync(String longitude, String latitude, String richterValue, String includeGeometry, final ApiCallback<EarthquakeRiskLocationResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getEarthquakeRiskByLocationCall(longitude, latitude, richterValue, includeGeometry, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<EarthquakeRiskLocationResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getEarthquakeRiskByLocationBatch */
    private com.squareup.okhttp.Call getEarthquakeRiskByLocationBatchCall(EarthquakeRiskByLocationRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        

        // create path and map variables
        String localVarPath = "/risks/v1/earthquake/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Post Earthquake Risk By Location
     * This is a Batch offering for &#39;Earthquake Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve counts of earthquakes for various richter measurements and values.
     * @param body  (optional)
     * @return EarthquakeRiskLocationResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public EarthquakeRiskLocationResponseList getEarthquakeRiskByLocationBatch(EarthquakeRiskByLocationRequest body) throws ApiException {
        ApiResponse<EarthquakeRiskLocationResponseList> resp = getEarthquakeRiskByLocationBatchWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Post Earthquake Risk By Location
     * This is a Batch offering for &#39;Earthquake Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve counts of earthquakes for various richter measurements and values.
     * @param body  (optional)
     * @return ApiResponse&lt;EarthquakeRiskLocationResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<EarthquakeRiskLocationResponseList> getEarthquakeRiskByLocationBatchWithHttpInfo(EarthquakeRiskByLocationRequest body) throws ApiException {
        com.squareup.okhttp.Call call = getEarthquakeRiskByLocationBatchCall(body, null, null);
        Type localVarReturnType = new TypeToken<EarthquakeRiskLocationResponseList>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Post Earthquake Risk By Location (asynchronously)
     * This is a Batch offering for &#39;Earthquake Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve counts of earthquakes for various richter measurements and values.
     * @param body  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getEarthquakeRiskByLocationBatchAsync(EarthquakeRiskByLocationRequest body, final ApiCallback<EarthquakeRiskLocationResponseList> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getEarthquakeRiskByLocationBatchCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<EarthquakeRiskLocationResponseList>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getFireHistory */
    private com.squareup.okhttp.Call getFireHistoryCall(String postCode, String startDate, String endDate, String maxCandidates, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'postCode' is set
        if (postCode == null) {
            throw new ApiException("Missing the required parameter 'postCode' when calling getFireHistory(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/risks/v1/firehistory".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (postCode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "postCode", postCode));
        if (startDate != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "startDate", startDate));
        if (endDate != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "endDate", endDate));
        if (maxCandidates != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "maxCandidates", maxCandidates));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Get Fire History
     * Accepts postcode as input and Returns fire event details for a particular postcode.
     * @param postCode 5 digit Postal code to search (required)
     * @param startDate Start time in milliseconds(UTC) (optional)
     * @param endDate End time in milliseconds(UTC) (optional)
     * @param maxCandidates Maximum response events (optional, default to 1)
     * @return FireHistory
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public FireHistory getFireHistory(String postCode, String startDate, String endDate, String maxCandidates) throws ApiException {
        ApiResponse<FireHistory> resp = getFireHistoryWithHttpInfo(postCode, startDate, endDate, maxCandidates);
        return resp.getData();
    }

    /**
     * Get Fire History
     * Accepts postcode as input and Returns fire event details for a particular postcode.
     * @param postCode 5 digit Postal code to search (required)
     * @param startDate Start time in milliseconds(UTC) (optional)
     * @param endDate End time in milliseconds(UTC) (optional)
     * @param maxCandidates Maximum response events (optional, default to 1)
     * @return ApiResponse&lt;FireHistory&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<FireHistory> getFireHistoryWithHttpInfo(String postCode, String startDate, String endDate, String maxCandidates) throws ApiException {
        com.squareup.okhttp.Call call = getFireHistoryCall(postCode, startDate, endDate, maxCandidates, null, null);
        Type localVarReturnType = new TypeToken<FireHistory>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get Fire History (asynchronously)
     * Accepts postcode as input and Returns fire event details for a particular postcode.
     * @param postCode 5 digit Postal code to search (required)
     * @param startDate Start time in milliseconds(UTC) (optional)
     * @param endDate End time in milliseconds(UTC) (optional)
     * @param maxCandidates Maximum response events (optional, default to 1)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getFireHistoryAsync(String postCode, String startDate, String endDate, String maxCandidates, final ApiCallback<FireHistory> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getFireHistoryCall(postCode, startDate, endDate, maxCandidates, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<FireHistory>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getFireRiskByAddress */
    private com.squareup.okhttp.Call getFireRiskByAddressCall(String address, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'address' is set
        if (address == null) {
            throw new ApiException("Missing the required parameter 'address' when calling getFireRiskByAddress(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/risks/v1/fire/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (address != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "address", address));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Get Fire Risk By Address
     * Accepts addresses as input and Returns fire risk data by risk types.
     * @param address Free-form address text (required)
     * @return FireRiskResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public FireRiskResponse getFireRiskByAddress(String address) throws ApiException {
        ApiResponse<FireRiskResponse> resp = getFireRiskByAddressWithHttpInfo(address);
        return resp.getData();
    }

    /**
     * Get Fire Risk By Address
     * Accepts addresses as input and Returns fire risk data by risk types.
     * @param address Free-form address text (required)
     * @return ApiResponse&lt;FireRiskResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<FireRiskResponse> getFireRiskByAddressWithHttpInfo(String address) throws ApiException {
        com.squareup.okhttp.Call call = getFireRiskByAddressCall(address, null, null);
        Type localVarReturnType = new TypeToken<FireRiskResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get Fire Risk By Address (asynchronously)
     * Accepts addresses as input and Returns fire risk data by risk types.
     * @param address Free-form address text (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getFireRiskByAddressAsync(String address, final ApiCallback<FireRiskResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getFireRiskByAddressCall(address, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<FireRiskResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getFireRiskByAddressBatch */
    private com.squareup.okhttp.Call getFireRiskByAddressBatchCall(FireRiskByAddressRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        

        // create path and map variables
        String localVarPath = "/risks/v1/fire/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Post Fire Risk By Address
     * This is a Batch offering for &#39;Fire Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve fire risk data by risk types.
     * @param body  (optional)
     * @return FireRiskResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public FireRiskResponseList getFireRiskByAddressBatch(FireRiskByAddressRequest body) throws ApiException {
        ApiResponse<FireRiskResponseList> resp = getFireRiskByAddressBatchWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Post Fire Risk By Address
     * This is a Batch offering for &#39;Fire Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve fire risk data by risk types.
     * @param body  (optional)
     * @return ApiResponse&lt;FireRiskResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<FireRiskResponseList> getFireRiskByAddressBatchWithHttpInfo(FireRiskByAddressRequest body) throws ApiException {
        com.squareup.okhttp.Call call = getFireRiskByAddressBatchCall(body, null, null);
        Type localVarReturnType = new TypeToken<FireRiskResponseList>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Post Fire Risk By Address (asynchronously)
     * This is a Batch offering for &#39;Fire Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve fire risk data by risk types.
     * @param body  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getFireRiskByAddressBatchAsync(FireRiskByAddressRequest body, final ApiCallback<FireRiskResponseList> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getFireRiskByAddressBatchCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<FireRiskResponseList>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getFireRiskByLocation */
    private com.squareup.okhttp.Call getFireRiskByLocationCall(String longitude, String latitude, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'longitude' is set
        if (longitude == null) {
            throw new ApiException("Missing the required parameter 'longitude' when calling getFireRiskByLocation(Async)");
        }
        
        // verify the required parameter 'latitude' is set
        if (latitude == null) {
            throw new ApiException("Missing the required parameter 'latitude' when calling getFireRiskByLocation(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/risks/v1/fire/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (longitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "longitude", longitude));
        if (latitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "latitude", latitude));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Get Fire Risk By Location
     * Accepts latitude &amp; longitude as input and Returns fire risk data by risk types.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @return FireRiskLocationResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public FireRiskLocationResponse getFireRiskByLocation(String longitude, String latitude) throws ApiException {
        ApiResponse<FireRiskLocationResponse> resp = getFireRiskByLocationWithHttpInfo(longitude, latitude);
        return resp.getData();
    }

    /**
     * Get Fire Risk By Location
     * Accepts latitude &amp; longitude as input and Returns fire risk data by risk types.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @return ApiResponse&lt;FireRiskLocationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<FireRiskLocationResponse> getFireRiskByLocationWithHttpInfo(String longitude, String latitude) throws ApiException {
        com.squareup.okhttp.Call call = getFireRiskByLocationCall(longitude, latitude, null, null);
        Type localVarReturnType = new TypeToken<FireRiskLocationResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get Fire Risk By Location (asynchronously)
     * Accepts latitude &amp; longitude as input and Returns fire risk data by risk types.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getFireRiskByLocationAsync(String longitude, String latitude, final ApiCallback<FireRiskLocationResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getFireRiskByLocationCall(longitude, latitude, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<FireRiskLocationResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getFireRiskByLocationBatch */
    private com.squareup.okhttp.Call getFireRiskByLocationBatchCall(FireRiskByLocationRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        

        // create path and map variables
        String localVarPath = "/risks/v1/fire/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Post Fire Risk By Location
     * This is a Batch offering for &#39;Fire Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve fire risk data by risk types.
     * @param body  (optional)
     * @return FireRiskLocationResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public FireRiskLocationResponseList getFireRiskByLocationBatch(FireRiskByLocationRequest body) throws ApiException {
        ApiResponse<FireRiskLocationResponseList> resp = getFireRiskByLocationBatchWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Post Fire Risk By Location
     * This is a Batch offering for &#39;Fire Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve fire risk data by risk types.
     * @param body  (optional)
     * @return ApiResponse&lt;FireRiskLocationResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<FireRiskLocationResponseList> getFireRiskByLocationBatchWithHttpInfo(FireRiskByLocationRequest body) throws ApiException {
        com.squareup.okhttp.Call call = getFireRiskByLocationBatchCall(body, null, null);
        Type localVarReturnType = new TypeToken<FireRiskLocationResponseList>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Post Fire Risk By Location (asynchronously)
     * This is a Batch offering for &#39;Fire Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve fire risk data by risk types.
     * @param body  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getFireRiskByLocationBatchAsync(FireRiskByLocationRequest body, final ApiCallback<FireRiskLocationResponseList> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getFireRiskByLocationBatchCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<FireRiskLocationResponseList>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getFireStationByAddress */
    private com.squareup.okhttp.Call getFireStationByAddressCall(String address, String maxCandidates, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String sortBy, String historicTrafficTimeBucket, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'address' is set
        if (address == null) {
            throw new ApiException("Missing the required parameter 'address' when calling getFireStationByAddress(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/risks/v1/firestation/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (address != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "address", address));
        if (maxCandidates != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "maxCandidates", maxCandidates));
        if (travelTime != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelTime", travelTime));
        if (travelTimeUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelTimeUnit", travelTimeUnit));
        if (travelDistance != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelDistance", travelDistance));
        if (travelDistanceUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelDistanceUnit", travelDistanceUnit));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sortBy", sortBy));
        if (historicTrafficTimeBucket != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "historicTrafficTimeBucket", historicTrafficTimeBucket));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Fire Station By Address
     * Accepts addresses as input and Returns nearest fire stations.
     * @param address The address to be searched. (required)
     * @param maxCandidates Specifies the maximum number of fire stations that this service retrieves. The default value is 3 and maximum value is 5. The retrieved results are traveldistance sorted from the input location. (optional)
     * @param travelTime Max travel time from input location to fire station. Maximum allowed is 2 hours (optional)
     * @param travelTimeUnit Travel time unit such as minutes (default), hours, seconds or milliseconds. (optional)
     * @param travelDistance Maximum travel distance from input location to fire station. Maximum allowed is 50 miles (optional)
     * @param travelDistanceUnit Travel distance unit such as Feet (default), Kilometers, Miles or Meters. (optional)
     * @param sortBy Sort the fire stations results by either travel time or travel distance (nearest first). Default sorting is by travel time. (optional)
     * @param historicTrafficTimeBucket Historic traffic time slab (optional)
     * @return FireStations
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public FireStations getFireStationByAddress(String address, String maxCandidates, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String sortBy, String historicTrafficTimeBucket) throws ApiException {
        ApiResponse<FireStations> resp = getFireStationByAddressWithHttpInfo(address, maxCandidates, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, sortBy, historicTrafficTimeBucket);
        return resp.getData();
    }

    /**
     * Fire Station By Address
     * Accepts addresses as input and Returns nearest fire stations.
     * @param address The address to be searched. (required)
     * @param maxCandidates Specifies the maximum number of fire stations that this service retrieves. The default value is 3 and maximum value is 5. The retrieved results are traveldistance sorted from the input location. (optional)
     * @param travelTime Max travel time from input location to fire station. Maximum allowed is 2 hours (optional)
     * @param travelTimeUnit Travel time unit such as minutes (default), hours, seconds or milliseconds. (optional)
     * @param travelDistance Maximum travel distance from input location to fire station. Maximum allowed is 50 miles (optional)
     * @param travelDistanceUnit Travel distance unit such as Feet (default), Kilometers, Miles or Meters. (optional)
     * @param sortBy Sort the fire stations results by either travel time or travel distance (nearest first). Default sorting is by travel time. (optional)
     * @param historicTrafficTimeBucket Historic traffic time slab (optional)
     * @return ApiResponse&lt;FireStations&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<FireStations> getFireStationByAddressWithHttpInfo(String address, String maxCandidates, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String sortBy, String historicTrafficTimeBucket) throws ApiException {
        com.squareup.okhttp.Call call = getFireStationByAddressCall(address, maxCandidates, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, sortBy, historicTrafficTimeBucket, null, null);
        Type localVarReturnType = new TypeToken<FireStations>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Fire Station By Address (asynchronously)
     * Accepts addresses as input and Returns nearest fire stations.
     * @param address The address to be searched. (required)
     * @param maxCandidates Specifies the maximum number of fire stations that this service retrieves. The default value is 3 and maximum value is 5. The retrieved results are traveldistance sorted from the input location. (optional)
     * @param travelTime Max travel time from input location to fire station. Maximum allowed is 2 hours (optional)
     * @param travelTimeUnit Travel time unit such as minutes (default), hours, seconds or milliseconds. (optional)
     * @param travelDistance Maximum travel distance from input location to fire station. Maximum allowed is 50 miles (optional)
     * @param travelDistanceUnit Travel distance unit such as Feet (default), Kilometers, Miles or Meters. (optional)
     * @param sortBy Sort the fire stations results by either travel time or travel distance (nearest first). Default sorting is by travel time. (optional)
     * @param historicTrafficTimeBucket Historic traffic time slab (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getFireStationByAddressAsync(String address, String maxCandidates, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String sortBy, String historicTrafficTimeBucket, final ApiCallback<FireStations> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getFireStationByAddressCall(address, maxCandidates, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, sortBy, historicTrafficTimeBucket, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<FireStations>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getFireStationByLocation */
    private com.squareup.okhttp.Call getFireStationByLocationCall(String longitude, String latitude, String maxCandidates, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String sortBy, String historicTrafficTimeBucket, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'longitude' is set
        if (longitude == null) {
            throw new ApiException("Missing the required parameter 'longitude' when calling getFireStationByLocation(Async)");
        }
        
        // verify the required parameter 'latitude' is set
        if (latitude == null) {
            throw new ApiException("Missing the required parameter 'latitude' when calling getFireStationByLocation(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/risks/v1/firestation/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (longitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "longitude", longitude));
        if (latitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "latitude", latitude));
        if (maxCandidates != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "maxCandidates", maxCandidates));
        if (travelTime != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelTime", travelTime));
        if (travelTimeUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelTimeUnit", travelTimeUnit));
        if (travelDistance != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelDistance", travelDistance));
        if (travelDistanceUnit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "travelDistanceUnit", travelDistanceUnit));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sortBy", sortBy));
        if (historicTrafficTimeBucket != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "historicTrafficTimeBucket", historicTrafficTimeBucket));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Fire Station By Location
     * Accepts latitude &amp; longitude as input and Returns nearest fire stations.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @param maxCandidates Specifies the maximum number of fire stations that this service retrieves. The default value is 3. The retrieved fire stations are distance ordered from the specified location. Maximum of 5 fire stations can be retrieved. (optional)
     * @param travelTime Maximum travel time from input location to fire station. Maximum allowed is 2 hours (optional)
     * @param travelTimeUnit Travel time unit such as minutes (default), hours, seconds or milliseconds. (optional)
     * @param travelDistance Maximum travel distance from input location to fire station. Maximum allowed is 50 miles (optional)
     * @param travelDistanceUnit Travel distance unit such as Feet (default), Kilometers, Miles or Meters. (optional)
     * @param sortBy Sorting of fire stations in result by travel time/distance (nearest first from input location). (optional)
     * @param historicTrafficTimeBucket Historic traffic time slab (optional)
     * @return FireStationsLocation
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public FireStationsLocation getFireStationByLocation(String longitude, String latitude, String maxCandidates, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String sortBy, String historicTrafficTimeBucket) throws ApiException {
        ApiResponse<FireStationsLocation> resp = getFireStationByLocationWithHttpInfo(longitude, latitude, maxCandidates, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, sortBy, historicTrafficTimeBucket);
        return resp.getData();
    }

    /**
     * Fire Station By Location
     * Accepts latitude &amp; longitude as input and Returns nearest fire stations.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @param maxCandidates Specifies the maximum number of fire stations that this service retrieves. The default value is 3. The retrieved fire stations are distance ordered from the specified location. Maximum of 5 fire stations can be retrieved. (optional)
     * @param travelTime Maximum travel time from input location to fire station. Maximum allowed is 2 hours (optional)
     * @param travelTimeUnit Travel time unit such as minutes (default), hours, seconds or milliseconds. (optional)
     * @param travelDistance Maximum travel distance from input location to fire station. Maximum allowed is 50 miles (optional)
     * @param travelDistanceUnit Travel distance unit such as Feet (default), Kilometers, Miles or Meters. (optional)
     * @param sortBy Sorting of fire stations in result by travel time/distance (nearest first from input location). (optional)
     * @param historicTrafficTimeBucket Historic traffic time slab (optional)
     * @return ApiResponse&lt;FireStationsLocation&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<FireStationsLocation> getFireStationByLocationWithHttpInfo(String longitude, String latitude, String maxCandidates, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String sortBy, String historicTrafficTimeBucket) throws ApiException {
        com.squareup.okhttp.Call call = getFireStationByLocationCall(longitude, latitude, maxCandidates, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, sortBy, historicTrafficTimeBucket, null, null);
        Type localVarReturnType = new TypeToken<FireStationsLocation>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Fire Station By Location (asynchronously)
     * Accepts latitude &amp; longitude as input and Returns nearest fire stations.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @param maxCandidates Specifies the maximum number of fire stations that this service retrieves. The default value is 3. The retrieved fire stations are distance ordered from the specified location. Maximum of 5 fire stations can be retrieved. (optional)
     * @param travelTime Maximum travel time from input location to fire station. Maximum allowed is 2 hours (optional)
     * @param travelTimeUnit Travel time unit such as minutes (default), hours, seconds or milliseconds. (optional)
     * @param travelDistance Maximum travel distance from input location to fire station. Maximum allowed is 50 miles (optional)
     * @param travelDistanceUnit Travel distance unit such as Feet (default), Kilometers, Miles or Meters. (optional)
     * @param sortBy Sorting of fire stations in result by travel time/distance (nearest first from input location). (optional)
     * @param historicTrafficTimeBucket Historic traffic time slab (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getFireStationByLocationAsync(String longitude, String latitude, String maxCandidates, String travelTime, String travelTimeUnit, String travelDistance, String travelDistanceUnit, String sortBy, String historicTrafficTimeBucket, final ApiCallback<FireStationsLocation> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getFireStationByLocationCall(longitude, latitude, maxCandidates, travelTime, travelTimeUnit, travelDistance, travelDistanceUnit, sortBy, historicTrafficTimeBucket, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<FireStationsLocation>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getFloodRiskByAddress */
    private com.squareup.okhttp.Call getFloodRiskByAddressCall(String address, String includeZoneDesc, String includeGeometry, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'address' is set
        if (address == null) {
            throw new ApiException("Missing the required parameter 'address' when calling getFloodRiskByAddress(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/risks/v1/flood/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (address != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "address", address));
        if (includeZoneDesc != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "includeZoneDesc", includeZoneDesc));
        if (includeGeometry != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "includeGeometry", includeGeometry));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Get Flood Risk By Address
     * Accepts addresses as input and Returns flood risk data for flood zones and base flood elevation values.
     * @param address Free-text Address (required)
     * @param includeZoneDesc Specifies primary zone description. Valid Values: &#39;Y&#39; or &#39;N&#39;. (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return FloodRiskResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public FloodRiskResponse getFloodRiskByAddress(String address, String includeZoneDesc, String includeGeometry) throws ApiException {
        ApiResponse<FloodRiskResponse> resp = getFloodRiskByAddressWithHttpInfo(address, includeZoneDesc, includeGeometry);
        return resp.getData();
    }

    /**
     * Get Flood Risk By Address
     * Accepts addresses as input and Returns flood risk data for flood zones and base flood elevation values.
     * @param address Free-text Address (required)
     * @param includeZoneDesc Specifies primary zone description. Valid Values: &#39;Y&#39; or &#39;N&#39;. (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return ApiResponse&lt;FloodRiskResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<FloodRiskResponse> getFloodRiskByAddressWithHttpInfo(String address, String includeZoneDesc, String includeGeometry) throws ApiException {
        com.squareup.okhttp.Call call = getFloodRiskByAddressCall(address, includeZoneDesc, includeGeometry, null, null);
        Type localVarReturnType = new TypeToken<FloodRiskResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get Flood Risk By Address (asynchronously)
     * Accepts addresses as input and Returns flood risk data for flood zones and base flood elevation values.
     * @param address Free-text Address (required)
     * @param includeZoneDesc Specifies primary zone description. Valid Values: &#39;Y&#39; or &#39;N&#39;. (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getFloodRiskByAddressAsync(String address, String includeZoneDesc, String includeGeometry, final ApiCallback<FloodRiskResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getFloodRiskByAddressCall(address, includeZoneDesc, includeGeometry, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<FloodRiskResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getFloodRiskByAddressBatch */
    private com.squareup.okhttp.Call getFloodRiskByAddressBatchCall(FloodRiskByAddressRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        

        // create path and map variables
        String localVarPath = "/risks/v1/flood/byaddress".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Post Flood Risk By Address
     * This is a Batch offering for &#39;Flood Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve flood risk data for flood zones and base flood elevation values.
     * @param body  (optional)
     * @return FloodRiskResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public FloodRiskResponseList getFloodRiskByAddressBatch(FloodRiskByAddressRequest body) throws ApiException {
        ApiResponse<FloodRiskResponseList> resp = getFloodRiskByAddressBatchWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Post Flood Risk By Address
     * This is a Batch offering for &#39;Flood Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve flood risk data for flood zones and base flood elevation values.
     * @param body  (optional)
     * @return ApiResponse&lt;FloodRiskResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<FloodRiskResponseList> getFloodRiskByAddressBatchWithHttpInfo(FloodRiskByAddressRequest body) throws ApiException {
        com.squareup.okhttp.Call call = getFloodRiskByAddressBatchCall(body, null, null);
        Type localVarReturnType = new TypeToken<FloodRiskResponseList>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Post Flood Risk By Address (asynchronously)
     * This is a Batch offering for &#39;Flood Risk By Address&#39; service. It accepts a single address or a list of addresses and retrieve flood risk data for flood zones and base flood elevation values.
     * @param body  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getFloodRiskByAddressBatchAsync(FloodRiskByAddressRequest body, final ApiCallback<FloodRiskResponseList> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getFloodRiskByAddressBatchCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<FloodRiskResponseList>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getFloodRiskByLocation */
    private com.squareup.okhttp.Call getFloodRiskByLocationCall(String longitude, String latitude, String includeZoneDesc, String includeGeometry, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'longitude' is set
        if (longitude == null) {
            throw new ApiException("Missing the required parameter 'longitude' when calling getFloodRiskByLocation(Async)");
        }
        
        // verify the required parameter 'latitude' is set
        if (latitude == null) {
            throw new ApiException("Missing the required parameter 'latitude' when calling getFloodRiskByLocation(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/risks/v1/flood/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (longitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "longitude", longitude));
        if (latitude != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "latitude", latitude));
        if (includeZoneDesc != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "includeZoneDesc", includeZoneDesc));
        if (includeGeometry != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "includeGeometry", includeGeometry));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Get Flood Risk By Location
     * Accepts latitude &amp; longitude as input and Returns flood risk data for flood zones and base flood elevation values.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @param includeZoneDesc Specifies primary zone description. Valid Values: &#39;Y&#39; or &#39;N&#39;. Default: &#39;Y&#39; (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return FloodRiskLocationResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public FloodRiskLocationResponse getFloodRiskByLocation(String longitude, String latitude, String includeZoneDesc, String includeGeometry) throws ApiException {
        ApiResponse<FloodRiskLocationResponse> resp = getFloodRiskByLocationWithHttpInfo(longitude, latitude, includeZoneDesc, includeGeometry);
        return resp.getData();
    }

    /**
     * Get Flood Risk By Location
     * Accepts latitude &amp; longitude as input and Returns flood risk data for flood zones and base flood elevation values.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @param includeZoneDesc Specifies primary zone description. Valid Values: &#39;Y&#39; or &#39;N&#39;. Default: &#39;Y&#39; (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @return ApiResponse&lt;FloodRiskLocationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<FloodRiskLocationResponse> getFloodRiskByLocationWithHttpInfo(String longitude, String latitude, String includeZoneDesc, String includeGeometry) throws ApiException {
        com.squareup.okhttp.Call call = getFloodRiskByLocationCall(longitude, latitude, includeZoneDesc, includeGeometry, null, null);
        Type localVarReturnType = new TypeToken<FloodRiskLocationResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get Flood Risk By Location (asynchronously)
     * Accepts latitude &amp; longitude as input and Returns flood risk data for flood zones and base flood elevation values.
     * @param longitude Longitude of Location (required)
     * @param latitude Latitude of Location (required)
     * @param includeZoneDesc Specifies primary zone description. Valid Values: &#39;Y&#39; or &#39;N&#39;. Default: &#39;Y&#39; (optional)
     * @param includeGeometry Y or N (default is N) - if it is Y, then geometry will be part of response (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getFloodRiskByLocationAsync(String longitude, String latitude, String includeZoneDesc, String includeGeometry, final ApiCallback<FloodRiskLocationResponse> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getFloodRiskByLocationCall(longitude, latitude, includeZoneDesc, includeGeometry, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<FloodRiskLocationResponse>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for getFloodRiskByLocationBatch */
    private com.squareup.okhttp.Call getFloodRiskByLocationBatchCall(FloodRiskByLocationRequest body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        

        // create path and map variables
        String localVarPath = "/risks/v1/flood/bylocation".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/xml", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json", "application/xml"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "oAuth2Password" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Post Flood Risk By Location
     * This is a Batch offering for &#39;Flood Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve flood risk data for flood zones and base flood elevation values.
     * @param body  (optional)
     * @return FloodRiskLocationResponseList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public FloodRiskLocationResponseList getFloodRiskByLocationBatch(FloodRiskByLocationRequest body) throws ApiException {
        ApiResponse<FloodRiskLocationResponseList> resp = getFloodRiskByLocationBatchWithHttpInfo(body);
        return resp.getData();
    }

    /**
     * Post Flood Risk By Location
     * This is a Batch offering for &#39;Flood Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve flood risk data for flood zones and base flood elevation values.
     * @param body  (optional)
     * @return ApiResponse&lt;FloodRiskLocationResponseList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<FloodRiskLocationResponseList> getFloodRiskByLocationBatchWithHttpInfo(FloodRiskByLocationRequest body) throws ApiException {
        com.squareup.okhttp.Call call = getFloodRiskByLocationBatchCall(body, null, null);
        Type localVarReturnType = new TypeToken<FloodRiskLocationResponseList>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Post Flood Risk By Location (asynchronously)
     * This is a Batch offering for &#39;Flood Risk By Location&#39; service. It accepts a single location coordinate or a list of location coordinates and retrieve flood risk data for flood zones and base flood elevation values.
     * @param body  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getFloodRiskByLocationBatchAsync(FloodRiskByLocationRequest body, final ApiCallback<FloodRiskLocationResponseList> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getFloodRiskByLocationBatchCall(body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<FloodRiskLocationResponseList>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
